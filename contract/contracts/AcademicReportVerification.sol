// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;
import "./Verifier.sol";

contract AcademicReportVerification {
    struct AcademicReport {
        bytes32 reportHash;
        uint issuanceDate;
        bool revoked;
        string issuer;
        bytes32 zkProof; // Placeholder for zk-SNARK proof for course completion without revealing grades
    }
   /* 
    "0x000000000000000000000000000000000000000000000000000000000001e240", // studentId as bytes32
"0xd5f293b137c0d2d2f2be1f0e5f0f3ef2a2d2f3e2f2e1f0f0b1c2d2e2f0f1f2f3", // reportHash
1619814400, // issuanceDate as UNIX timestamp
"University Name", // issuer
"0xa1b2c3d4e5f60102f3e2d1c0b1a2f3e4d5c6b7a8e9f0010203040506070809ff" // zkProof
*/

    address private owner;
    Verifier private verifier; // Instance of the Verifier contract

    mapping(address => bool) private authorizedIssuers;
    mapping(bytes32 => AcademicReport) private reports;

    event ReportIssued(bytes32 indexed reportId, string issuer, uint issuanceDate);
    event ReportRevoked(bytes32 indexed reportId);

    modifier onlyOwner() {
        require(msg.sender == owner, "This action is restricted to the owner.");
        _;
    }

    modifier onlyAuthorizedIssuer() {
        require(authorizedIssuers[msg.sender], "This action is restricted to authorized issuers.");
        _;
    }

    constructor() {
        owner = msg.sender;
        verifier = Verifier(0xd2a5bC10698FD955D1Fe6cb468a17809A08fd005/* Address of the Verifier.sol*/); // Initialize Verifier instance

    }

    // Owner can authorize or revoke issuer rights
    function setIssuerAuthorization(address issuer, bool authorized) external onlyOwner {
        authorizedIssuers[issuer] = authorized;
    }

    function checkIssuerStatus (address issuer) public view returns (bool) {
        return authorizedIssuers[issuer];
    }

    // Issue a new academic report
    function issueReport(bytes32 studentId, bytes32 reportHash, uint issuanceDate, string calldata issuer, bytes32 zkProof) external onlyAuthorizedIssuer {
        bytes32 reportId = keccak256(abi.encodePacked(studentId, reportHash, issuanceDate));
        require(reports[reportId].issuanceDate == 0, "Report already issued.");

        reports[reportId] = AcademicReport({
            reportHash: reportHash,
            issuanceDate: issuanceDate,
            revoked: false,
            issuer: issuer,
            zkProof: zkProof
        });
        /* Eg Input for Above Function 

        "0x000000000000000000000000000000000000000000000000000000000001e240", // studentId as bytes32
        "0xd5f293b137c0d2d2f2be1f0e5f0f3ef2a2d2f3e2f2e1f0f0b1c2d2e2f0f1f2f3", // reportHash
        1619814400, // issuanceDate as UNIX timestamp
        "University Name", // issuer
        "0xa1b2c3d4e5f60102f3e2d1c0b1a2f3e4d5c6b7a8e9f0010203040506070809ff" // zkProof
    
        */

        emit ReportIssued(reportId, issuer, issuanceDate);
    }

    // Revoke an academic report
    function revokeReport(bytes32 reportId) external onlyAuthorizedIssuer {
        require(reports[reportId].issuanceDate != 0, "Report does not exist.");
        reports[reportId].revoked = true;

        emit ReportRevoked(reportId);
    }

    // Check if a report is revoked
    function isReportRevoked(bytes32 reportId) external view returns (bool) {
        require(reports[reportId].issuanceDate != 0, "Report does not exist.");
        return reports[reportId].revoked;
    }

    // Verify report using zk-SNARK proof (simplified version)
   function verifyReport(
    bytes32 reportId //, 
    // uint[2] memory a,
    // uint[2][2] memory b,
    // uint[2] memory c,
    // uint[3] memory input
) public view returns (bool) {
    require(reports[reportId].issuanceDate != 0, "Report does not exist.");
    uint[2] memory a;
    uint[2][2] memory b;
    uint[2] memory c;
    uint[3] memory input;
// for the sake of testing the hardcoded values have been given, on further allowance will make it dynamically inputed from the frontend 
// these are the values of the proof generated by our zokrates zero knowledge program (proof.json)
 a = [
    uint256(0x2c1bb1343121e45ef7aa89c61ec431319abf10f290f67658860ef3a8b9a835d6),
    uint256(0x2e79b0808d6b95416345ad7af0bdfb48c834a9c30d7d24a5b2ac4e5d049c8246)
];

 b = [
    [uint256(0x2120c02726b582cd8eb6c4c572e3821ac84078c4dcc3084f707f8769f8230d3a), uint256(0x0854ab5cf77a6cd7c8b23f5d304206ccea020639b819c8631e77fb3707439531)],
    [uint256(0x0522e8d72874089ea2e115a64c18e0e5a68bd0919b55d6d2882798c79f58a9ff), uint256(0x05f45de5dcc8027588977aeb5a86e3572d4c098afb6010ffe872e74f78bb6eee)]
];

c = [
    uint256(0x137d8d8a4e01c291af8979e27a20e597cb868288fcbc5e1c9d088b1d94a44c74),
    uint256(0x036fc61bfefe69e08cfadfae338399aee58150f2c03a4cdeb4a9242d642ee3b5)
];

input = [
    uint256(0x00000000000000000000000000000000000000000000000000000000000004d2),
    uint256(0x0000000000000000000000000000000000000000000000000000000000000001),
    uint256(0x0000000000000000000000000000000000000000000000000000000000000001)
];

    Pairing.G1Point memory pointA = Pairing.G1Point(a[0], a[1]);
    Pairing.G2Point memory pointB = Pairing.G2Point([b[0][0], b[0][1]], [b[1][0], b[1][1]]);
    Pairing.G1Point memory pointC = Pairing.G1Point(c[0], c[1]);

    Verifier.Proof memory proof = Verifier.Proof({
        a: pointA,
        b: pointB,
        c: pointC
    });

    bool verified = verifier.verifyTx(proof, input);
    return verified && !reports[reportId].revoked;
}
}

// Thank you, i hope you give me a chance to finish this project in the next round ...